using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class NewBehaviourScript : MonoBehaviour {


    public float[] A;

	void Start ()
    {
        Sorting(0, A.Length-1, A);

        for(int i=0;i<A.Length;i++)
        {
            Debug.Log(A[i]);
        }
    }
	



    //QuickSort快速排序演算法
    void Sorting(int start, int end, float[] data)
    //說明：Partition Exchange Sort (Quick Sort) - Median-3法
    //輸入：start, end = 要排序資料的起終範圍, data = 輸入資料
    //輸出：data = 已排序好的資料
    //效率：平均情況為O(nlogn)，最差情況為O(n^2)
    //實測：(32,1.7us),(256,18.1us),(1K,86.6us),(4K,400us),(64K,7.97ms),(256K,35.1ms),
    //	(1M,154ms),(16M,2.93s)
    //實測：(32,1.8us),(256,19.2us),(1K,89.7us),(4K,413us),(64K,8.33ms),(256K,36.4ms),
    //	(1M,161ms),(16M,3.06s)
    //	已排序好資料再新加一個資料時：(1K,143us),(16K,56.41ms),(256K,13.8s)
    {
        while (start < end) // 此迴圈係用以模擬第二次的遞迴呼叫排序 //
        {
            // 取分堆標準元素 (使用Median-3法) //
            int m = (start + end) / 2;
            if (data[start] > data[m])
            {
                float temp = data[start];
                data[start] = data[m];
                data[m] = temp;
            }
            if (data[start] > data[end])
            {
                float temp = data[start];
                data[start] = data[end];
                data[end] = temp;
            }
            if (data[m] > data[end])
            {
                float temp = data[m];
                data[m] = data[end];
                data[end] = temp;
            }
            float k = data[m];
            // 開始依k值挑元素分堆, 小的放左邊, 大的放右邊 //
            int i = start;
            int j = end;
            do
            {
                // 由左找第一個比k大的 //
                while (data[i] < k) i++;
                // 由右找第一個比k小的 //
                while (k < data[j]) j--;
                // 將i與j位置上的資料對調 //
                if (i <= j)
                {
                    float temp = data[i];
                    data[i] = data[j];
                    data[j] = temp;
                    i++;
                    j--;
                }
            } while (i <= j);
            // 遞迴呼叫排序較小的那塊 (呼叫次數與深度較少) //
            // 然後重設參數, 以迴圈模擬遞迴呼叫, 排序較大的那塊 //
            if (j - start < end - i) // 左半部較小 //
            {
                if (start < j) Sorting(start, j, data);
                start = i;
            }
            else // 右半部較小 //
            {
                if (i < end) Sorting(i, end, data);
                end = j;
            }
        }
    }






}
